
# Лабораторная работа 01: Введение в алгоритмы. Сложность. Поиск

## Цель работы
Освоить понятие вычислительной сложности алгоритмов.  
Получить практические навыки реализации и анализа линейного и бинарного поиска.  
Научиться экспериментально подтверждать теоретические оценки сложности **O(n)** и **O(log n)**.

---

## Теория

- **Сложность алгоритма** - Характеризует количество ресурсов (времени и памяти), необходимых
 алгоритму для обработки входных данных объема n
- **Асимптотический анализ:** - Анализ поведения алгоритма при стремлении n к бесконечности.
 Позволяет абстрагироваться от констант и аппаратных особенностей.
- **O-нотация («О-большое»)** - Верхняя асимптотическая оценка роста функции. Определяет
 наихудший сценарий работы алгоритма.
- **Линейный поиск (Linear Search)** - Последовательный перебор всех элементов массива. Сложность: O(n)
- **Бинарный поиск (Binary Search)** -Поиск в отсортированном массиве путем многократного
 деления интервала поиска пополам. Сложность: O(log n). Требует предварительной сортировки
 (O(n log n)).

### Линейный поиск
- Перебор элементов массива последовательно.  
- В худшем случае проверяет все `n` элементов.  
- Сложность: **O(n)**.  

### Бинарный поиск
- Работает только на отсортированном массиве.  
- На каждом шаге делит интервал поиска пополам.  
- Количество шагов пропорционально `log₂(n)`.  
- Сложность: **O(log n)**.  
- Дополнительно: сортировка массива перед поиском имеет сложность **O(n log n)**.

---

## Практика

### Задание
1. Реализовать функции:
   - `linear_search(arr, target)`  
   - `binary_search(arr, target)`  
2. Добавить комментарии с оценкой сложности каждой строки.  
3. Провести замеры времени выполнения для разных размеров массива.  
4. Построить графики зависимости времени от размера массива.  
5. Сравнить теоретическую и практическую сложность.  

### Подготовка данных
- Сгенерированы отсортированные массивы: `[1000, 5000, 10000, 50000, 100000, 500000]`.  
- Для поиска выбран элемент: **последний** (худший случай).  

### Характеристики ПК
- Процессор: AMD Ryzen 5 5600G @ 4.30GHz
- Оперативная память: 16 GB DDR4
- ОС: Windows 11
- Python: 3.13


---

## Результаты замеров

Таблица (время в миллисекундах, усреднение по 10 запускам):

| Размер (n) | Линейный (мс) | Бинарный (мс) |
|------------|----------------|----------------|
| 1 000      | 0.0130         | 0.0009         |
| 5 000      | 0.0832         | 0.0013         |
| 10 000     | 0.1992         | 0.0010         |
| 50 000     | 2.0518         | 0.0015         |
| 100 000    | 0.3474         | 0.0016         |
| 500 000    | 22.0347        | 0.0018         |
| 1 000 000  | 69.0726        | 0.0019         |


## Графики

### 1. В линейном масштабе и логарифмическом масштабах
![Сравнение линейного и бинарного поиска](search_comparison.png)

---

## Анализ результатов

1. Теоретически:
   - Линейный поиск: **O(n)**.  
   - Бинарный поиск: **O(log n)**.  
2. Эксперименты подтвердили:
   - Время линейного поиска растёт **пропорционально n**.  
   - Время бинарного поиска растёт максимально медленно, **по 0.0001 мс за каждый поиск по мере увеличения размера (n)**. 
3. Разница особенно заметна на больших массивах: бинарный поиск работает в сотни раз быстрее.  

---

## Выводы
- Реализованы линейный и бинарный поиск.  
- Погрешности в замерах обусловлены многозадачностью ОС, кэшированием, работой интерпретатора Python и случайными колебаниями времени на микросекундных интервалах. Для больших массивов они не влияют на общий тренд: линейный поиск растёт пропорционально N, бинарный почти не изменяется.
- Полученные замеры подтверждают теоретическую асимптотику.  
- Бинарный поиск значительно эффективнее при больших входных данных. 
- Работа показала важность выбора алгоритма: асимптотическая разница даёт колоссальный выигрыш на практике.  
- Линейный поиск показывает линейный рост времени
- Бинарный поиск демонстрирует логарифмическую сложность