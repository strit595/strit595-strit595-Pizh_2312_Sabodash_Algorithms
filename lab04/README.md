# Отчет по лабораторной работе №4
# Алгоритмы сортировки

**Дата:** 2025.30.11 
**Семестр:** 5 семестр
**Группа:** ПИЖ-б-о-23-1  
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Сабодаш Алексей Игоревич  

## Цель работы
Изучить и реализовать основные алгоритмы сортировки. Провести их теоретический и практический сравнительный анализ по временной и пространственной сложности. Исследовать влияние начальной упорядоченности данных на эффективность алгоритмов. Получить навыки эмпирического анализа производительности алгоритмов.

## Теоретическая часть

### 1. Сортировка пузырьком (Bubble Sort)
**Сложность:**
- Время: **O(n²)** во всех случаях
- Память: **O(1)**
- Устойчивость: **да**

### 2. Сортировка выбором (Selection Sort)
**Сложность:**
- Время: **O(n²)** во всех случаях
- Память: **O(1)**
- Устойчивость: **нет**

### 3. Сортировка вставками (Insertion Sort)
**Сложность:**
- Лучший случай: **O(n)**
- Средний: **O(n²)**
- Худший: **O(n²)**
- Память: **O(1)**
- Устойчивость: **да**

### 4. Сортировка слиянием (Merge Sort)
**Сложность:**
- Время: **O(n log n)** во всех случаях
- Память: **O(n)**
- Устойчивость: **да**

### 5. Быстрая сортировка (Quick Sort)
**Сложность:**
- Средний случай: **O(n log n)**
- Худший случай: **O(n²)**
- Память: **O(log n)**
- Устойчивость: **нет**

## Практическая часть

### Характеристики ПК
- **Процессор:** AMD Ryzen 5 5600G @ 4.30GHz
- **Оперативная память:** 16 GB DDR4
- **ОС:** Windows 11
- **Python:** 3.13

### Результаты тестирования

На основе предоставленных данных проведен анализ производительности 5 алгоритмов сортировки на массивах размеров 100, 500, 1000, 5000, 10000 элементов для 4 типов данных: случайные, отсортированные, обратно отсортированные, почти отсортированные.

#### Сводная таблица производительности (время в миллисекундах)

| Algorithm | Size | Data Type | Time (ms) |
|-----------|------|-----------|-----------|
| bubble_sort | 100 | random | 0.31 |
| selection_sort | 100 | random | 0.21 |
| insertion_sort | 100 | random | 0.19 |
| merge_sort | 100 | random | 0.24 |
| quick_sort | 100 | random | 0.12 |
| bubble_sort | 10000 | random | 6500.47 |
| selection_sort | 10000 | random | 3539.87 |
| insertion_sort | 10000 | random | 3429.11 |
| merge_sort | 10000 | random | 39.34 |
| quick_sort | 10000 | random | 33.88 |

### Анализ результатов

#### Сравнение теоретических оценок с практическими результатами

| Алгоритм | Сложность | Практическая картина |
|----------|-----------|---------------------|
| **Bubble Sort** | O(n²) / O(n²) / O(n) | Медленный на всех типах данных, особенно на больших массивах (n=10000 → 6500 мс) |
| **Selection Sort** | O(n²) / O(n²) / O(n²) | Стабильно медленный, практически не зависит от типа данных |
| **Insertion Sort** | O(n²) / O(n²) / O(n) | Очень быстрый на отсортированных данных (1.38 мс для n=10000), медленный на случайных |
| **Merge Sort** | O(n log n) / O(n log n) / O(n log n) | Стабильно быстрый на всех типах данных |
| **Quick Sort** | O(n²) / O(n log n) / O(n log n) | Самый быстрый на случайных данных, стабильная производительность |

#### Наиболее эффективный алгоритм для каждого типа данных

**Случайные данные** → **Quick Sort** (33.88 мс для n=10000)

**Отсортированные данные** → **Insertion Sort** (1.2 мс для n=10000)

**Обратно отсортированные** → **Quick Sort** (16.54 мс для n=10000)

**Почти отсортированные** → **Insertion Sort** (642 мс для n=10000)

#### Поведение алгоритмов на краевых случаях

**Quick Sort**: На обратно отсортированных данных показывает отличную производительность (18.54 мс для n=10000), что свидетельствует об удачном выборе опорного элемента (медиана трех).

**Insertion Sort**: На отсортированных данных демонстрирует феноменальную производительность - в 2500 раз быстрее, чем на случайных данных для n=10000.

**Bubble Sort**: На отсортированных данных также эффективен (0.78 мс для n=10000), но абсолютно непрактичен на случайных данных.

## Выводы

1. **Quick Sort** - оптимальный выбор для большинства практических задач, демонстрируя наилучшую производительность на случайных данных.

2. **Insertion Sort** исключительно эффективен для маленьких массивов (<1000) и почти отсортированных данных, показывая адаптивность к структуре данных.

3. **Merge Sort** обеспечивает гарантированное время O(n log n) и устойчивость, что важно для специфических задач.

4. **Bubble Sort и Selection Sort** не рекомендуются для использования на больших массивах из-за квадратичной сложности.

5. Разница в производительности между алгоритмами O(n²) и O(n log n) достигает **200 раз** для n=10000, что полностью подтверждает теоретические оценки.

## Ответы на контрольные вопросы

### 1. Какие алгоритмы сортировки имеют сложность O(n²) в худшем случае, а какие — O(n log n)?

**O(n²)**: Bubble Sort, Selection Sort, Insertion Sort  
**O(n log n)**: Merge Sort, Quick Sort (в среднем случае)

### 2. Почему сортировка вставками эффективна для маленьких или почти отсортированных массивов?

Insertion Sort эффективен благодаря адаптивности - на почти отсортированных данных количество операций сдвига минимально, что дает сложность близкую к O(n). Для маленьких массивов накладные расходы рекурсивных алгоритмов превышают простоту Insertion Sort.

### 3. В чем разница между устойчивой и неустойчивой сортировкой?

Устойчивые (Bubble, Insertion, Merge) сохраняют порядок равных элементов, неустойчивые (Selection, Quick) - нет.

### 4. Опишите принцип работы Quick Sort

Алгоритм выбирает опорный элемент, разделяет массив на элементы меньше и больше опорного, затем рекурсивно сортирует части. Выбор опорного элемента критически влияет на производительность.

### 5. Когда Merge Sort предпочтительнее Quick Sort?

Merge Sort предпочтительнее когда требуется гарантированное время O(n log n), устойчивость или работа с внешней памятью.

## Приложения

![Зависимость времени сортировки от размера массива](comprehensive_performance.png)

![Сравнение алгоритмов по типам данных](algorithm_comparison_histogram.png)

![Тепловая карта производительности](performance_heatmap.png)