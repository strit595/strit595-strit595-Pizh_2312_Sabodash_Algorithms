# Отчет по лабораторной работе №8: Жадные алгоритмы

**Дата:** 2025-12-14  
**Семестр:** 5 семестр
**Группа:** ПИЖ-б-о-23-1  
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Сабодаш Алексей Игоревич

## Цель работы

Изучить метод проектирования алгоритмов, известный как "жадный алгоритм". Освоить принцип принятия локально оптимальных решений на каждом шаге и понять условия, при которых этот подход приводит к глобально оптимальному решению. Получить практические навыки реализации жадных алгоритмов для решения классических задач, анализа их корректности и оценки эффективности.

## Теоретическая часть

**Жадный алгоритм:** Алгоритм, который на каждом шаге принимает локально оптимальное решение в надежде, что итоговое решение будет глобально оптимальным.

**Ключевые характеристики:**
- **Жадный выбор:** На каждом шаге выбирается лучший из доступных вариантов в данный момент
- **Оптимальная подструктура:** Оптимальное решение задачи содержит в себе оптимальные решения её подзадач

**Классические задачи:**
- **Задача о выборе заявок (Interval Scheduling):** Выбор максимального количества непересекающихся интервалов
- **Непрерывный рюкзак (Fractional Knapsack):** Выбор предметов с максимальной суммарной стоимостью

## Практическая часть

### Выполненные задачи

1. Реализован алгоритм выбора заявок (`interval_scheduling`)
2. Реализован алгоритм для непрерывного рюкзака (`fractional_knapsack`)
3. Проведен сравнительный анализ эффективности жадного подхода

### Ключевые фрагменты кода

```python
# Interval Scheduling (сортировка по времени окончания)
sorted_intervals = sorted(intervals, key=lambda x: x[1])
    
    selected = []
    last_end_time = -float('inf')
    
    for interval in sorted_intervals:
        start, end = interval
        if start >= last_end_time:
            selected.append(interval)
            last_end_time = end
    
    return selected

# Fractional Knapsack (сортировка по удельной стоимости)
 items_with_ratio = []
    for weight, value in items:
        if weight > 0:
            ratio = value / weight
            items_with_ratio.append((weight, value, ratio))
    
    # Сортируем по удельной стоимости по убыванию
    items_with_ratio.sort(key=lambda x: x[2], reverse=True)
    
    total_value = 0.0
    knapsack_items = []
    remaining_capacity = capacity
    
    for weight, value, ratio in items_with_ratio:
        if remaining_capacity <= 0:
            break
        
        if weight <= remaining_capacity:
            # Берем предмет целиком
            taken_weight = weight
            taken_value = value
            remaining_capacity -= weight
        else:
            # Берем часть предмета
            taken_weight = remaining_capacity
            taken_value = value * (remaining_capacity / weight)
            remaining_capacity = 0
        
        total_value += taken_value
        knapsack_items.append((taken_weight, taken_value))
    
    return total_value, knapsack_items
```

## Результаты выполнения

### 1. Задача о выборе заявок (Interval Scheduling)

**Тестовые данные:**  
`[(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11), (8, 12), (2, 13), (12, 14)]`

**Результат:**  
Выбрано 4 интервала: `[(1, 4), (5, 7), (8, 11), (12, 14)]`

**Анализ:**  
- Всего интервалов: 11
- Выбрано интервалов: 4 (максимально возможное)
- Интервалы не пересекаются: проверено
- **Сложность:** O(n log n)

**Объяснение оптимальности:** Алгоритм сортирует интервалы по времени окончания и последовательно выбирает интервалы, которые начинаются после окончания последнего выбранного. Выбор интервала с наименьшим временем окончания оставляет максимальное свободное время для следующих интервалов.

### 2. Непрерывный рюкзак (Fractional Knapsack)

**Тестовые данные:**  
- Предметы: `[(10, 60), (20, 100), (30, 120)]`
- Вместимость рюкзака: 50

**Результат:**  
- Максимальная стоимость: 240.00
- Взятые предметы:
  - Предмет 1: 10кг, 60$, 100.00%
  - Предмет 2: 20кг, 100$, 100.00%
  - Предмет 3: 30кг, 120$, 66.67%

**Анализ:**  
- Удельные стоимости: 6.0, 5.0, 4.0
- **Сложность:** O(n log n)
- **Оптимальность:** Гарантируется для непрерывной версии

### 3. Алгоритм Хаффмана

**Тестовые данные:**  
Частоты символов: `{'a': 0.4, 'b': 0.3, 'c': 0.2, 'd': 0.1}`

**Результат:**  
Коды Хаффмана:
- 'a': 0
- 'b': 10
- 'c': 111
- 'd': 110

**Анализ производительности:**
- Время выполнения: 0.000040 сек
- Средняя длина кода: 1.900 бит/символ
- Эффективность: 97.18%
- **Сложность:** O(n log n)

## Сравнительный анализ: Жадный подход vs 0-1 Рюкзак

### Эксперимент 1: Демонстрация работы жадного алгоритма

**Тестовые данные:**
- Предметы: `[(2, 40), (3, 50), (5, 100), (7, 140), (1, 20)]`
- Вместимость: 10

**Результаты:**
- Жадный алгоритм (непрерывный): 200.00 (0.000027 сек)
- Точный алгоритм (0-1, перебор): 200 (0.000116 сек)
- Оптимальная комбинация: предметы 1, 4, 5

**Вывод:** Для этих данных жадный алгоритм дает тот же результат, что и точное решение.

### Эксперимент 2: Демонстрация неоптимальности

**Тестовые данные:**
- Предметы: `[(10, 60), (20, 100), (30, 120)]`
- Вместимость: 50

**Анализ:**
- Удельные стоимости: 6.0, 5.0, 4.0
- Жадный выбор для 0-1:
  - Берет предмет 1 (вес 10, стоимость 60)
  - Свободное место: 40
  - Итог: стоимость 60
- Оптимальный выбор:
  - Берет предметы 2 и 3 (вес 50, стоимость 220)
  - Итог: стоимость 220

**Вывод:** Жадный алгоритм не оптимален для дискретного рюкзака 0-1.

## Производительность алгоритмов

**Сравнительная таблица временной сложности:**

| Алгоритм | Сложность | Примечания |
|----------|-----------|------------|
| Interval Scheduling | O(n log n) | Сортировка по времени окончания |
| Fractional Knapsack | O(n log n) | Сортировка по удельной стоимости |

**Результаты измерения времени выполнения:**
- Interval Scheduling: мгновенное выполнение
- Fractional Knapsack: 0.000546 сек

## Ответы на контрольные вопросы

### 1. В чем заключается основная идея жадных алгоритмов?

Основная идея жадных алгоритмов заключается в принятии локально оптимального решения на каждом шаге в надежде, что это приведет к глобально оптимальному решению. Алгоритм никогда не пересматривает свои решения и не учитывает будущие последствия текущего выбора.

### 2. Для задачи о выборе заявок (Interval Scheduling) жадный алгоритм, выбирающий интервалы с наименьшим временем окончания, является оптимальным. Объясните, почему.

Доказательство оптимальности основано на методе замены. Пусть есть оптимальное решение, отличное от жадного. Рассмотрим первую позицию, где они различаются. Жадный алгоритм выбрал интервал с наименьшим временем окончания, значит, он заканчивается не позже, чем интервал в оптимальном решении. Заменив интервал в оптимальном решении на интервал из жадного, мы получим решение, которое имеет такое же количество интервалов и освобождает больше времени для следующих интервалов. Таким образом, жадный выбор не ухудшает решение, а значит, алгоритм оптимален.

### 3. Приведите пример задачи, для которой жадный алгоритм дает оптимальное решение, и задачи, для которой он не дает.

**Оптимальное решение:**
- Непрерывный рюкзак (Fractional Knapsack)
- Выбор заявок (Interval Scheduling)

**Не оптимальное решение:**
- Дискретный рюкзак 0-1
- Задача коммивояжера (TSP)

### 4. В чем разница между непрерывной (дробной) и дискретной (0-1) задачами о рюкзаке? Для какой из них жадный алгоритм оптимален?

**Разница:**
- Непрерывная задача: Можно брать дробные части предметов
- Дискретная задача 0-1: Предметы берутся только целиком

**Оптимальность:**
- Жадный алгоритм оптимален для непрерывной задачи
- Жадный алгоритм не оптимален для дискретной задачи 0-1

**Причина:** В непрерывной задаче всегда можно взять часть "лучшего" предмета. В дискретной задаче взятие "лучшего" предмета может помешать взять комбинацию предметов с большей суммарной стоимостью.

### 5. Опишите жадный алгоритм построения кода Хаффмана. В чем его оптимальность?

**Алгоритм:**
1. Создать узел для каждого символа с весом, равным частоте
2. Поместить все узлы в минимальную кучу
3. Пока в куче больше одного узла:
   - Извлечь два узла с наименьшими весами
   - Создать новый внутренний узел с весом, равным сумме весов
   - Сделать извлеченные узлы детьми нового узла
   - Добавить новый узел в кучу
4. Оставшийся узел - корень дерева Хаффмана

**Оптимальность:** Алгоритм Хаффмана строит оптимальное префиксное кодирование, минимизируя среднюю длину кода. Оптимальность доказывается через свойства:
1. Два наименее частых символа имеют коды одинаковой максимальной длины
2. В оптимальном коде эти символы являются листьями с общим родителем
3. Рекурсивное применение этого принципа дает оптимальное дерево

## Выводы

1. **Эффективность жадных алгоритмов:** Реализованные алгоритмы демонстрируют высокую производительность (полиномиальное время выполнения) и для многих задач дают оптимальное решение.

2. **Область применения:** Жадные алгоритмы эффективны для задач, обладающих свойствами жадного выбора и оптимальной подструктуры:
   - Задача о выборе заявок
   - Непрерывный рюкзак
   - Алгоритм Хаффмана

3. **Ограничения:** Жадный подход не всегда приводит к оптимальному решению:
   - Дискретный рюкзак 0-1 (демонстрирует неоптимальность)
   - Для задач без свойства жадного выбора